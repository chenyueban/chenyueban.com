{"data":{"site":{"siteMetadata":{"title":"月半小夜曲","author":"chenyueban"}},"markdownRemark":{"id":"51c88b91-ef51-557a-be94-c87392a3f447","excerpt":"前端现在是黎明前的黑暗，在几年内一定会明晰起来 前言 随着前端代码日益膨胀，JSer 开始需要通过模块化规范去管理代码。 由于在 ES6 之前并没有规范化的模块化机制，所以社区也是不断涌现出各种解决方案，比如文件拆分、全局变量、命名空间，以及  YUI3  式的模块化开发方式。 后来  CommonJS…","html":"<blockquote>\n<p>前端现在是黎明前的黑暗，在几年内一定会明晰起来</p>\n</blockquote>\n<h2>前言</h2>\n<p>随着前端代码日益膨胀，JSer 开始需要通过模块化规范去管理代码。</p>\n<p>由于在 ES6 之前并没有规范化的模块化机制，所以社区也是不断涌现出各种解决方案，比如文件拆分、全局变量、命名空间，以及 <a href=\"https://github.com/seajs/seajs/issues/547\">YUI3</a> 式的模块化开发方式。</p>\n<p>后来 <strong>CommonJS</strong> 登上了舞台，一举取代了之前各种模块化方式的地位，至于原因我想这篇<a href=\"https://github.com/seajs/seajs/issues/547\">文章</a>讲解的非常清晰了。</p>\n<h2>CommonJS</h2>\n<p><a href=\"http://wiki.commonjs.org/wiki/CommonJS\">CommonJS</a> 原来叫 <strong>ServerJS</strong>，推出了 <a href=\"http://wiki.commonjs.org/wiki/Modules\">Modules/1.0</a> 规范并在 <code class=\"language-text\">Node.js</code> 下获得了成功，在这之后 <strong>ServerJS</strong> 将希望成果运用到浏览器端，于是社区改名为 <strong>CommonJS</strong>，同时激烈讨论 Modules 的下一版规范，分歧就此产生，逐步形成了三大流派：</p>\n<ol>\n<li><strong>Modules/1.x</strong> 这个流派认为 1.X 规范已经够用，只要移植到浏览器端就好。要做的是新增 <a href=\"http://wiki.commonjs.org/wiki/Modules/Transport\">Modules/Transport</a> 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 <strong>Transport</strong> 规范的代码。主流代表是服务端的开发人员。</li>\n<li><strong>Modules/Async</strong> 这个观点觉得浏览器有自身的特征，不应该直接用 <strong>Modules/1.x</strong> 规范。这个观点下的典型代表是 AMD 规范及其实现 <a href=\"https://requirejs.org/\">RequireJS</a>。</li>\n<li><strong>Modules/2.0</strong> 这个观点觉得浏览器有自身的特征，不应该直接用 <strong>Modules/1.x</strong> 规范，但应该尽可能与 <strong>Modules/1.x</strong> 规范保持一致。这个观点下的典型代表是 <a href=\"https://code.google.com/archive/p/bravojs\">BravoJS</a> 和 <strong>FlyScript</strong> 的作者。<strong>FlyScript</strong> 的作者提出了 <a href=\"http://wiki.commonjs.org/wiki/Modules/Wrappings\">Modules/Wrappings</a> 规范，这规范是 <strong>CMD</strong> 规范的前身。可惜的是 <strong>BravoJS</strong> 太学院派，<strong>FlyScript</strong> 后来做了自我阉割，将整个网站（flyscript.org）下线了。</li>\n</ol>\n<h3>CommonJS 加载机制</h3>\n<p>这里要讲的是 <strong>Modules/1.X</strong> 规范的语法，即 Node.js 采用的规范。</p>\n<ul>\n<li>导出模块：<code class=\"language-text\">module.exports = value</code> or <code class=\"language-text\">exports.xxx = value</code></li>\n<li>导入模块：<code class=\"language-text\">require(xxx)</code></li>\n</ul>\n<p>每一个文件就是 <strong>CommonJS</strong> 的一个模块，使用 <code class=\"language-text\">require</code> 加载模块时将执行整个文件，然后在内存中生成一个对象，需要时就会到这个对象上面取值。所以即使我们重复 <code class=\"language-text\">require</code> 同一个模块，都只会运行一次文件。</p>\n<p>所以，<strong>CommonJS 模块的导入是导出模块的值的拷贝</strong>，一旦导出，即使导出模块内部发生了变化，导出的值也不会随之变化。这与 ES6 的模块化截然不同。</p>\n<h2>AMD 与 RequireJS</h2>\n<blockquote>\n<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>\n<p>RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。</p>\n</blockquote>\n<p><strong>AMD</strong> 对模块的态度是预执行：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'./a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'./b'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 依赖必须一开始就写好</span>\n  a<span class=\"token punctuation\">.</span><span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 此处略去 100 行</span>\n  b<span class=\"token punctuation\">.</span><span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>而 <strong>Modules/1.X</strong> 则不同：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./a\"</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 执行到此处时，a.js 才同步下载并执行</span></code></pre></div>\n<p>这应该是 <strong>AMD</strong> 与其他规范最大的差异，我更偏向于 <strong>Modules/1.X</strong> 规范，但是不评论二者的好与坏，毕竟从这个方面看，现在的 ES6 的模块机制 更偏向 <strong>AMD</strong>。</p>\n<h2>CMD 与 SeaJS</h2>\n<p><strong>SeaJS</strong> 起源于 <strong>Modules/2.0</strong>，但更多的加入了许多实战派的理念。</p>\n<blockquote>\n<p>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p>\n</blockquote>\n<p><strong>CMD</strong> 对模块的态度是 懒执行：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>require<span class=\"token punctuation\">,</span> exports<span class=\"token punctuation\">,</span> module<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./a'</span><span class=\"token punctuation\">)</span>\n   a<span class=\"token punctuation\">.</span><span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n   <span class=\"token comment\">// 此处略去 100 行</span>\n   <span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./b'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 依赖可以就近书写</span>\n   b<span class=\"token punctuation\">.</span><span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>从这一方面看，CMD 更相像于 <strong>Modules/1.X</strong>。</p>\n<p><a href=\"https://www.zhihu.com/question/20351507/answer/14859415\">虽然 <strong>AMD</strong> 也支持 <strong>CMD</strong> 的写法，同时还支持将 <code class=\"language-text\">require</code> 作为依赖项传递，但 <strong>RequireJS</strong> 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。</a></p>\n<h2>UMD</h2>\n<p><strong>UMD</strong> 是 <strong>AMD</strong> 和 <strong>CommonJS</strong> 的糅合。</p>\n<p><strong>UMD</strong> 的存在像是语法糖，首先判断是否支持 <strong>CommonJS</strong> ：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>global<span class=\"token punctuation\">,</span> factory<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">typeof</span> exports <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> module <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span> <span class=\"token comment\">// 判断是否支持 CommonJS</span>\n  <span class=\"token operator\">?</span> module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token function\">factory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">:</span> <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>然后判断是否支持 <strong>AMD</strong>：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>global<span class=\"token punctuation\">,</span> factory<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">typeof</span> exports <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> module <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span> <span class=\"token comment\">// 判断是否支持 CommonJS</span>\n  <span class=\"token operator\">?</span> module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token function\">factory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">:</span> <span class=\"token keyword\">typeof</span> define <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span> <span class=\"token operator\">&amp;&amp;</span> define<span class=\"token punctuation\">.</span>amd <span class=\"token comment\">// 判断是否支持 AMD</span>\n    <span class=\"token operator\">?</span> <span class=\"token function\">define</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>global<span class=\"token punctuation\">.</span>React <span class=\"token operator\">=</span> <span class=\"token function\">factory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>ES6 模块化</h2>\n<p>前文提到 <strong>CommonJS</strong> 模块的导入是导出模块的值的拷贝。</p>\n<p>与此不同，<strong>ES6 模块输出的是值的引用</strong>，除此之外：</p>\n<ul>\n<li><strong>CommonJS</strong> 模块是运行时加载，<strong>ES6 模块</strong>是编译时输出接口。</li>\n<li><strong>CommonJS</strong> 加载的是一个对象，对象只有在文件运行完才能生成，而 <strong>ES6 模块</strong>在代码静态解析阶段就会生成。</li>\n</ul>\n<p>可以理解为引擎对文件静态分析时，遇到 <code class=\"language-text\">import</code> 会生成一个只读引用，等文件真正执行时，根据只读引用到被加载的模块内取值。因此 <strong>ES6 模块</strong>不需要缓存值。</p>\n<h2>最后</h2>\n<p>无论是 <strong>CommonJS</strong> <strong>AMD</strong> <strong>CMD</strong> 到最后的 <strong>ES6 模块</strong>，都是 JSer 在不断探索最优解决方案的产物，前端正处于黎明前的黑暗，正一步步走向光明的未来，而处在这条路上的 JSer，正是不断探索发觉未来的奠基者。</p>\n<p>参考：</p>\n<ol>\n<li><a href=\"https://github.com/seajs/seajs/issues/588\">前端模块化开发那点历史</a></li>\n<li><a href=\"https://www.zhihu.com/question/20351507/answer/14859415\">AMD 和 CMD 的区别有哪些</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/module-loader\">Module 的加载实现</a></li>\n</ol>","frontmatter":{"title":"聊聊前端模块化","date":"February 22, 2019","description":"前端现在是黎明前的黑暗，在几年内一定会明晰起来"}}},"pageContext":{"slug":"/聊聊前端模块化/","previous":null,"next":{"fields":{"slug":"/聊聊前端语义化的今天/"},"frontmatter":{"title":"聊聊前端语义化的今天"}}}}